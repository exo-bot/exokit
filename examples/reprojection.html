<!doctype html>
<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script>
 window.ScreenQuad = (() => {

      var defaultQuad = new THREE.PlaneBufferGeometry(2,2,1000, 1000);

      var defaultVertexShader = [

        "varying vec2 vUv;",
        "uniform sampler2D dTexture;",
        "uniform mat4 projectionMatrixInverse;",
        "uniform mat4 matrixWorldInverse;",
        "uniform mat4 inverseMatrix;",
        "uniform mat4 inverseMatrix2;",
        "uniform mat4 initialProjectionMatrix;",
        "uniform float zNear;",
        "uniform float zFar;",
        "uniform float aspect;",
        `
        /* vec4 screen2WorldOld(vec2 screen) {
          // input: x_coord, y_coord
          vec2 xy = (screen + 1.0) / 2.0; //in [0,1] range
          // vec2 xy = screen;
          vec4 v_screen = vec4(xy, texture2D(dTexture, xy).r, 1.0 );
          vec4 v_homo = projectionMatrixInverse * 2.0*(v_screen-vec4(0.5));
          // vec3 v_eye = v_homo.xyz / v_homo.w; //transfer from homogeneous coordinates
          // return vec4(screen.xy, v_homo.z/v_homo.w, v_homo.w);
          return modelViewMatrix * vec4(screen.xy, v_homo.z/v_homo.w, 1.0);
        } */
        vec4 screen2World(vec2 screen) {
          vec2 xy = (screen + 1.0) / 2.0; //in [0,1] range
          float z_b = texture2D(dTexture, xy).r;
          float z_n = 2.0 * z_b - 1.0;
          float z_e = 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
          // float z_e = zNear + (z_b)*(zFar - zNear)
          vec4 offset = initialProjectionMatrix * vec4(0.0, 0.0, -z_e, 1.0);
          float z = offset.z/offset.w;
          return projectionMatrix * modelViewMatrix * inverseMatrix2 * vec4(screen.xy, z, 1.0);
        }
        `,
        "void main(){",
          "gl_Position = screen2World(position.xy);",
          "vUv = uv;",
        "}",

      ].join("\n");

      var defaultFragmentShader = [

        `varying vec2 vUv;
        uniform float numTextures;
        uniform sampler2D uTexture;
        uniform sampler2D dTexture;
        void main() {
          vec4 c = texture2D(uTexture, vUv);
          float d = (1.0 - texture2D(dTexture, vUv).r) * 20.0;
          gl_FragColor = vec4(vec3(d) * c.rgb, c.a);
        }`

      ].join("\n");

      function ScreenQuad( params ){

        params = params || {};

        THREE.Mesh.apply( this, [ defaultQuad , new THREE.ShaderMaterial({

          uniforms:{
            numTextures: {
              type: 'f',
              value: undefined !== params.numTextures ? params.numTextures : 1
            },
            uTexture: {
              type:'t',
              value: undefined !== params.texture ? params.texture : null
            },
            dTexture: {
              type:'t',
              value: undefined !== params.depthTexture ? params.depthTexture : null
            },
            projectionMatrixInverse: {
              type:'m4',
              value: undefined !== params.projectionMatrixInverse ? params.projectionMatrixInverse : null
            },
            matrixWorldInverse: {
              type:'m4',
              value: undefined !== params.matrixWorldInverse ? params.matrixWorldInverse : null
            },
            inverseMatrix: {
              type:'m4',
              value: undefined !== params.inverseMatrix ? params.inverseMatrix : null
            },
            inverseMatrix2: {
              type:'m4',
              value: undefined !== params.inverseMatrix2 ? params.inverseMatrix2 : null
            },
            initialProjectionMatrix: {
              type:'m4',
              value: undefined !== params.initialProjectionMatrix ? params.initialProjectionMatrix : null
            },
            zNear: {
              type:'f',
              value: undefined !== params.zNear ? params.zNear : null
            },
            zFar: {
              type:'f',
              value: undefined !== params.zFar ? params.zFar : null
            },
            aspect: {
              type:'f',
              value: undefined !== params.aspect ? params.aspect : null
            },
          },

          vertexShader: defaultVertexShader,

          fragmentShader: defaultFragmentShader,

          // depthWrite: !params.lol,

          transparent: true,

        })]);

        this.frustumCulled = false;

        this.renderOrder = -1;

        //end mesh setup

        // console.log( this , this.width , this.height );

      }

      ScreenQuad.prototype = Object.create( THREE.Mesh.prototype );

      ScreenQuad.constructor = ScreenQuad;

      return ScreenQuad

})();
    </script>
    <script>
let renderer, scene, hiddenScene, camera, hiddenCamera, iframe, boxMesh, boxMesh2, renderTarget, screenQuad;

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localCoord = new THREE.Vector2();
const localPlane = new THREE.Plane();
const localLine = new THREE.Line3();
const localLine2 = new THREE.Line3();

const planeWorldWidth = 0.9;
const planeWorldHeight = 0.9;
const boxMeshSize = 1;
const planeWidth = 1280;
const planeHeight = 1024;

function init() {
  renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  // window.browser.magicleap.RequestDepthPopulation(true);
  // renderer.autoClear = false;

  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.matrixAutoUpdate = false;

  hiddenScene = new THREE.Scene();
  hiddenScene.matrixAutoUpdate = false;

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 1;
  scene.add(camera);

  new THREE.OrbitControls(camera);

  hiddenCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  hiddenCamera.position.copy(camera.position);
  hiddenScene.add(hiddenCamera);
  hiddenCamera.updateMatrixWorld();
  hiddenCamera.updateProjectionMatrix();
  hiddenCamera.inverseMatrix = new THREE.Matrix4();
  hiddenCamera.inverseMatrix2 = new THREE.Matrix4();
  hiddenCamera.initialProjectionMatrix = new THREE.Matrix4();

  {
    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);
  }
  {
    const ambientLight = new THREE.AmbientLight(0x808080);
    hiddenScene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    hiddenScene.add(directionalLight);
  }

  const vertexShader = [
    'attribute vec2 uv;',
    'varying vec2 vUv;',
    'void main() {',
      'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
      'vUv = uv;',
    '}'
  ].join('\n');
  const fragmentShader = [
    'sampler2D t;',
    'varying vec2 vUv;',
    'void main() {',
      'gl_FragColor = texture2D(t, vUv);',
    '}'
  ].join('\n');

  const _makeBoxMesh = () => {
    const geometry = new THREE.BoxBufferGeometry(boxMeshSize, boxMeshSize, boxMeshSize);
    const material = new THREE.MeshPhongMaterial({
      color: 0xFF0000,
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = Math.PI / 4;
    mesh.rotation.y = Math.PI / 4;
    mesh.rotation.z = Math.PI / 4;
    mesh.rotation.order = 'YXZ';
    return mesh;
  };
  boxMesh = _makeBoxMesh();
  boxMesh.position.z = -2;
  scene.add(boxMesh);

  boxMesh2 = _makeBoxMesh();
  boxMesh2.position.z = -2;
  hiddenScene.add(boxMesh2);

  renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
    format: THREE.RGBAFormat,
  });
  // renderTarget.transparent = false;
  renderTarget.depthTexture = new THREE.DepthTexture(window.innerWidth, window.innerHeight);

  screenQuad = new ScreenQuad({
    texture: renderTarget.texture,
    depthTexture: renderTarget.depthTexture,
    projectionMatrixInverse: hiddenCamera.projectionMatrixInverse,
    matrixWorldInverse: hiddenCamera.matrixWorldInverse,
    zNear: hiddenCamera.near,
    zFar: hiddenCamera.far,
    aspect: hiddenCamera.aspect,
    inverseMatrix: hiddenCamera.inverseMatrix,
    inverseMatrix2: hiddenCamera.inverseMatrix2,
    initialProjectionMatrix: hiddenCamera.initialProjectionMatrix,
    lol: true,
  });
  scene.add(screenQuad);
}

init();

window.addEventListener('keydown', e => {
  boxMesh2.position.copy(boxMesh.position);
  boxMesh2.quaternion.copy(boxMesh.quaternion);
  boxMesh2.scale.copy(boxMesh.scale);

  hiddenCamera.position.copy(camera.position);
  hiddenCamera.quaternion.copy(camera.quaternion);
  hiddenCamera.scale.copy(camera.scale);
  hiddenCamera.updateMatrixWorld();
  hiddenCamera.updateProjectionMatrix();

  screenQuad.position.copy(camera.position);
  screenQuad.quaternion.copy(camera.quaternion);
  screenQuad.scale.copy(camera.scale);
  screenQuad.updateMatrixWorld();

  hiddenCamera.inverseMatrix.copy(hiddenCamera.matrixWorld).multiply(screenQuad.matrixWorld);
  hiddenCamera.inverseMatrix.getInverse(hiddenCamera.inverseMatrix);
  hiddenCamera.inverseMatrix2.copy(hiddenCamera.projectionMatrixInverse);
  hiddenCamera.initialProjectionMatrix.copy(hiddenCamera.projectionMatrix);

  renderer.render(hiddenScene, hiddenCamera, renderTarget);
  renderer.setRenderTarget(null);
});

function animate(timestamp, frame) {
  boxMesh.rotation.x += 0.01;
  boxMesh.rotation.y += 0.01;
  boxMesh.rotation.z += 0.01;

  renderer.render(scene, camera);
}

  renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
